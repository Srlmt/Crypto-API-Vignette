---
title: "Using R to Interact with Cryptocurrency API"
author: "Joey Chen"
date: "10/5/2021"
---

```{r packages and API, include=FALSE}
library(tidyverse)
library(jsonlite)
library(knitr)
library(lubridate)

APIkey="r87x5acIqxjYxZWZ31xO3dxUjQGVlja6"
```

```{r graphics crypto intro, echo=FALSE}
include_graphics(path="images/crypto.jpg")
```

# Introduction

Cryptocurrencies have gained traction over the past couple or years. As the trend continues, some may want to perform data exploration or analysis. 

This document will go over the processes of using R to interact with the cryptocurrency [Application Programming Interface (API)](https://www.mulesoft.com/resources/api/what-is-an-api). It will go over the requirements and useful functions, followed by data exploration examples and conclusion.

# Requirements

```{r graphics packages, echo=FALSE}
include_graphics(path="images/packages.png")
```

### R Packages

The following packages are required to use the API function:

  + [`tidyverse`](https://www.tidyverse.org/): Useful data tools for transforming and visualizing data
  + [`jsonlite`](https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html): Interact and download data with API
  + [`knitr`](https://cran.r-project.org/web/packages/knitr/index.html): Display well-formatted tables
  + [`lubridate`](https://lubridate.tidyverse.org/): Useful date functions (part of `tidyverse`)

### API Key

You will also need an API key to be able to interact with the API. Please go to [polygon.io](https://polygon.io/) to register for a free API key. You will need to assign the key to the variable `APIkey`, as follows: 

```{r APIkey, eval=FALSE}
APIkey = "insert_key_here"
```

# Functions to Interact with API

I have created 6 useful functions and a separate wrapper function to conveniently call any of the 6 functions. Each of the functions would return an R data frame that can be readily used. The functions modify URLs to call the API and retrieve data from different parts of the API.

Please keep in mind that this API is limited to **5 API Calls / Minute**. R would return an error if that is exceeded. 

We will now go over the functions:  

  
## (1) `getExchange` 

**Description:** Function to get Crypto Exchanges Data

**Input:** None

**Output:** Returns a table of exchange data information

```{r exchange}

getExchange <- function(){
  
   # Build the URL  
   baseURL <- "https://api.polygon.io/v1/meta/crypto-exchanges/"
   key <- paste0("?apiKey=", APIkey)
   URL <- paste0(baseURL, key)
   
   # Use the URL to retrieve data from API
   exchangeData <- fromJSON(URL)
   
   return(exchangeData)
}

# Sample Function Call
kable(getExchange())
```
  
  
## (2) `getNews` 

**Description:** Function to get Bitcoin news. It currently does not work for any other cryptocurrencies.

**Input:** None

**Output:** Returns a table of Bitcoin news such as title, author, and link. 

```{r news, warning=FALSE}

getNews <- function(){
  
   # Build the URL  
   baseURL <- "https://api.polygon.io/v2/reference/news?limit=20&order=descending&sort=published_utc&ticker=BTC"
   key <- paste0("&apiKey=", APIkey)
   URL <- paste0(baseURL, key)
   
   # Use the URL to retrieve data from API
   newsList <- fromJSON(URL)
   
   # Select meaningful variables from the `results` table
   newsData <- newsList$results %>% select(publisher, title, author, published_utc, article_url)
   
   return(newsData)
}

# Sample Function Call
kable(head(getNews(), n=3))
```
  
  
## (3) `getDailyMarket` 

**Description:** Function to get the daily grouped data for the entire Crypto market

**Input:** Date in "YYYY-MM-DD" format

**Output:** Returns a table of containing crypto market information on the input date

```{r DailyMarket}
getDailyMarket <- function(date=Sys.Date()){

   # Build the URL
   baseURL <- "https://api.polygon.io/v2/aggs/grouped/locale/global/market/crypto/"
   key <- paste0("?apiKey=", APIkey)
   day <- date
   URL <- paste0(baseURL, day, key)
   
   # Use the URL to retrieve data from API
   dailyMarketList <- fromJSON(URL)
   
    # Select meaningful variables from the `results` table
   dailyMarketData <- dailyMarketList$results %>% select(ticker = T, volume = v, priceOpen = o, priceClose = c)
   
   return(dailyMarketData)
}

# Sample Function Call
kable(head(getDailyMarket("2021-09-30"), n=5))
```
  
  
## (4) `getTickerDetails` 

**Description:** Function to get more information about the input ticker

**Input:** Ticker name. Examples: "BTCUSD" or "ETHUSD"

**Output:** Returns a table of ticker information such as currency symbol and name

```{r TickerDetails, warning=FALSE}

getTickerDetails <- function(ticker){

   # Build the URL  
   baseURL <- "https://api.polygon.io/vX/reference/tickers/"
   symbol <- paste0("X:", ticker)
   key <- paste0("?apiKey=", APIkey)
   URL <- paste0(baseURL, symbol, key)
   
   # Use the URL to retrieve data from API
   tickerList <- fromJSON(URL)
   
   # Select meaningful variables from the `results` table
   tickerData <- as.data.frame(tickerList$results) %>% select(ticker, name, market, locale, currency_name, base_currency_symbol, base_currency_name)
   
   return(tickerData)
}

# Sample Function Call
kable(getTickerDetails("ETHUSD"))
```
  
  
## (5) `getPreviousClose` 

**Description:** Function to get the previous day's open, high, low, and close for the input cryptocurrency

**Input:** Cryptocurrency pair ticker. Example: "BTCUSD" or "ETHUSD"

**Output:** Returns a table of containing previous day's data

```{r PreviousClose}
getPreviousClose <- function(ticker){
      
   baseURL <- "https://api.polygon.io/v2/aggs/ticker/"
   symbol <- paste0("X:", ticker, "/")
   otherSettings <- "prev?adjusted=true"
   key <- paste0("&apiKey=", APIkey)
   URL <- paste0(baseURL, symbol, otherSettings, key)
   
   # Use the URL to retrieve data from API
   prevCloseList <- fromJSON(URL)
   
   # Select meaningful variables from the `results` table
   prevCloseData <- prevCloseList$results %>% select(ticker = T, volume = v, priceOpen = o, priceClose = c, priceLowest = l, priceHighest = h)

   return(prevCloseData)   
}

#Sample Function Call
kable(getPreviousClose("ETHUSD"))
```
  
  
## (6) `getAggregates` 

**Description:** Function to get 1-year aggregate data for a cryptocurrency pair ending at a given date

**Input:** Date in "YYYY-MM-DD" format

**Output:** Returns a table of containing crypto market information such as daily volume and price

```{r Aggregates}
getAggregates <- function(date=Sys.Date(), ticker){

   # Retrieve the date 1 year prior to the input date
   dayEnd <- as.Date(date)
   dayStart <- dayEnd - 364
   
   # Build the URL
   baseURL <- "https://api.polygon.io/v2/aggs/ticker/"
   symbol <- paste0("X:", ticker, "/")
   range <- "range/1/day/"
   otherSettings <- "?adjusted=true&sort=asc&limit=365"
   key <- paste0("&apiKey=", APIkey)
   URL <- paste0(baseURL, symbol, range, dayStart, "/", dayEnd, otherSettings, key)
   
   # Use the URL to retrieve data from API
   aggregateList <- fromJSON(URL)
   aggregateData <- aggregateList$results
   
   # The table from API does not have the date, so we will create it
   date_range <- as.Date(c(dayStart:dayEnd), origin = "1970-01-01")
   
   # Get the Quarter of the date (from lubridate package)
   qtr <- paste0(year(date_range), " Q", quarter(date_range))
   
   cryptoData <- data.frame(qtr, date_range, aggregateData$v, aggregateData$o, aggregateData$c)
   colnames(cryptoData) <- c("quarter", "date", "volume", "priceOpen", "priceClose")
   
   return(cryptoData)
}

kable(head(getAggregates("2021-09-30", ticker="BTCUSD"), n=5))
```
  
  
## (7)[Wrapper] `cryptoAPI`

**Description:** Wrapper function to call any of the 6 functions above. 

**Input:** The `func` parameter can take either the function id (1-6) or the function name (in quotes). 

For functions that need the `ticker` variable, you can supply either the `name` or the `ticker` argument. Examples of `name` are "bitcoin" or "ETHEREUM", and examples of `ticker` are "btcusd" "ethUSD". The letter case do not matter since they will be converted and mapped correctly within the function. 

**Output:** Returns the output from the specific function called

```{r wrapper}
cryptoAPI <- function(func, name="", ticker="", date=Sys.Date()){
   
   # Check if `func` is numeric (1-6)
   # If it is outside of (1-6), return an error message
   # If it is within 1 to 6, map to the corresponding function
   if (is.numeric(func)){
      if (!between(func, 1, 6)){
         stop("ERROR: There are only 6 functions. Please input a valid function ID (1 to 6)")
      } else{
        func <- switch(func,
                    "getExchange",
                    "getNews",
                    "getDailyMarket",
                    "getTickerDetails",
                    "getPreviousClose",
                    "getAggregates")
      } 
   }
   
   # Check to see if either `name` or `ticker` is provided
   # Some functions do not require these arguments
   if (name != "" | ticker != ""){
   
      # Allow user to specify either the crypto currency name or the ticker name
      # Map the name to the corresponding ticker
      # Only the top 10 cryptocurrencies (by market cap) are supported
      if (name != ""){
      symbol <- switch(toupper(name),
                       BITCOIN = "BTCUSD",
                       ETHEREUM = "ETHUSD",
                       CARDANO = "ADAUSD",
                       XRP = "XRPUSD",
                       SOLANA = "SOLUSD",
                       POLKADOT = "DOTUSD",
                       DOGECOIN = "DOGEUSD",
                       UNISWAP = "UNIUSD",
                       CHAINLINK = "LINKUSD",
                       LITECOIN = "LTCUSD",
                       )
      } else if (ticker != ""){
        symbol <- toupper(ticker)
      } 
      
      # Check to see if the ticker is mapped correctly
      if (symbol == ""){
         message <- paste("ERROR: Only the top 10 cryptocurrencies by market cap are supported,", 
                          "please input another name, or use the `ticker` and input a valid Crypto ticker")
         stop(message)
         
      # Use function 3 `getDailyMarket` to check for valid ticker names
      }
      
   
   # For functions that require the input, check to see if the ticker is mapped correctly      
   }else if(name == "" & ticker == "" & func %in% c("getTickerDetails", "getPreviousClose", "getAggregates")){
      stop("ERROR: Missing cryptocurrency name or ticker input required for this function")
   }   
   
   
   # Function 1
   if (func == "getExchange"){
      output <- getExchange()
   
   # Function 2      
   }else if (func == "getNews"){
      output <- getNews()
      
   # Function 3   
   }else if (func == "getDailyMarket"){
      output <- getDailyMarket(date)
   
   # Function 4      
   }else if (func == "getTickerDetails"){
      output <- getTickerDetails(symbol)
   
   # Function 5   
   }else if (func == "getPreviousClose"){
      output <- getPreviousClose(symbol)
   
   # Function 6      
   }else if (func == "getAggregates"){
      output <- getAggregates(date, symbol)
   
   # Return error message if the function name is not mapped correctly   
   }else{
      stop("ERROR: The `func` argument is not valid")
   }
   
   return(output)
}
```
  
The following are examples of valid functions calls:

```{r valid function calls, eval=FALSE}
cryptoAPI(1)
cryptoAPI("getNews")
cryptoAPI(3)
cryptoAPI("getTickerDetails", name="cardano")
cryptoAPI(5, ticker="ethusd")
cryptoAPI(6, name="eThErEuM")
```

  
```{r pause 60s, include=FALSE}
# This is for the RMarkdown render to pause 60 seconds when reaching this point
# Since the API limit is 5 Calls / Minute, we have called the API 5 times above
# Waiting 1 minute would allow us to continue calling the API later in the document
Sys.sleep(60)
```
  
# Data Exploration

We will now use some of the above functions to retrieve data from the API and perform some data exploration. 

## Top Cryptocurrencies

```{r graphics crypto market, echo=FALSE, out.width="400px"}
include_graphics(path="images/crypto.jpg")
```

We can first look at 6 of the top cryptocurrencies by market cap. We will calculate the YTD price change by using "2021-01-01" as the baseline date and "2021-09-30" as the comparison date. We can use the `cryptoAPI` wrapper function to call the `getDailyMarket` function using the two dates. Then we can merge the two datasets and calculate the YTD change. 

```{r Crypto Market, include=FALSE}
# Call the wrapper function and specify the desired function name 
marketBaseline <- cryptoAPI("getDailyMarket", date="2021-01-01") 

# Alternative way to call the API using the function ID
marketCurrent <- cryptoAPI(3, date="2021-09-30")

# Merge the two datasets from API
# Only get the 6 Top cryptocurrencies
# Calculate percent change and map the tickers to their respective cryptocurrency names
marketData <- merge(marketBaseline, marketCurrent, by="ticker") %>%
                  filter(ticker %in% c("X:BTCUSD", "X:ETHUSD", "X:ADAUSD", "X:XRPUSD", "X:DOGEUSD", "X:LTCUSD")) %>%
                  select(ticker, priceBase = priceClose.x, priceCurrent = priceClose.y) %>%
                  mutate(pctChange = (priceCurrent - priceBase) / priceBase,
                         cryptoCurrency = ifelse(ticker=="X:BTCUSD", "Bitcoin",
                                ifelse(ticker=="X:ETHUSD", "Ethereum",
                                ifelse(ticker=="X:ADAUSD", "Cardano",
                                ifelse(ticker=="X:XRPUSD", "XRP",
                                ifelse(ticker=="X:DOGEUSD", "Dogecoin",
                                ifelse(ticker=="X:LTCUSD", "Litecoin", "Check Ticker")))))))
# Show data
kable(marketData)
```
  
Now we can visualize the data by creating a bar plot of the YTD change.
  
```{r barplot}
ggplot(marketData, aes(x=cryptoCurrency, y=pctChange, fill=cryptoCurrency)) +
   geom_bar(stat="identity") +
   scale_y_continuous(labels = scales::percent) +
   labs(title="YTD Price Change as of 2021-09-30 in 6 Top Cryptocurrencies", 
        y="YTD % Change") +
   theme(text=element_text(size=14),
         legend.position = "none")
```
From the graph we can see that Dogecoin has the highest YTD change by far, with approximately +3500% increase. Cardano also has a large YTD change with over 1000% increase. In contrast, Bitcoin and Litecoin has the lowest YTD change. 
  
  
## Bitcoin vs Ethereum

```{r BTC ETH image, echo=FALSE}
include_graphics(path="images/bitcoin_vs_ethereum.jpg")
```

Ethereum, the second largest cryptocurrency by market cap, is often compared to Bitcoin. As of 2021-10-02, Bitcoin has a market cap of \$900 million, while Ethereum has a market cap of \$400 million. We can  first look at the performance of the two cryptocurrencies over the past year. We will grab the 1 year data ending on "2021-09-30" from the API, since that would give us 4 complete quarters. 

```{r BTC ETH performance}
bitcoinData <- cryptoAPI("getAggregates", name="Bitcoin", date="2021-09-30")
ethereumData <- cryptoAPI(6, name="Ethereum", date="2021-09-30")

calcPerformance <- function(price){

   change1Day <- scales::percent((price[365] - price[364]) / price[364], accuracy=0.1)
   change7Day <- scales::percent((price[365] - price[358]) / price[358], accuracy=0.1)
   change30Day <-scales::percent((price[365] - price[335]) / price[335], accuracy=0.1)
   changeYear <- scales::percent((price[365] - price[1]) / price[1], accuracy=0.1)
   
   scales::label_percent(c(change1Day, change7Day))
   
   performanceData <- cbind(price = price[365], '24h %' = change1Day, '7d %' = change7Day, '30d %' = change30Day, 'yr %' = changeYear)
   
   return(performanceData)
}

bitcoinPerformance <- cbind(cryptocurrency = "Bitcoin", calcPerformance(bitcoinData$priceClose))
ethereumPerformance <- cbind(cryptocurrency = "Ethereum", calcPerformance(ethereumData$priceClose))

kable(rbind(bitcoinPerformance, ethereumPerformance))
```


```{r}
bitcoinData$cryptoCurrency <- "Bitcoin"
ethereumData$cryptoCurrency <- "Ethereum"

combinedData <- rbind(bitcoinData, ethereumData)
combinedData$dayPerformance <- ifelse(combinedData$priceClose - combinedData$priceOpen >= 0, "Gain", "Loss")
combinedData$dayChange <- scales::percent((combinedData$priceClose - combinedData$priceOpen) / combinedData$priceOpen, accuracy=0.01)


table(combinedData$quarter, combinedData$dayPerformance, combinedData$cryptoCurrency)
```





```{r boxplots}
ggplot(filter(combinedData, cryptoCurrency=="Bitcoin"), aes(quarter, volume)) +
   geom_boxplot(size=1) +
   geom_jitter(aes(y=volume, fill=dayPerformance, color=dayPerformance), size=2) +
   labs(title="Boxplot for Bitcoin Trading Volume by Quarter") +
   theme(text=element_text(size=16), 
         panel.grid.major = element_line(size=1.5),
         axis.ticks = element_line(size=1.4),
         axis.ticks.length = unit(0.20, 'cm')) +
   scale_color_manual(values = c("Gain" = "lightgreen", "Loss" = "red"))

ggplot(filter(combinedData, cryptoCurrency=="Ethereum"), aes(quarter, volume)) +
   geom_boxplot(size=1) +
   geom_jitter(aes(y=volume, fill=dayPerformance, color=dayPerformance), size=2) +
   labs(title="Boxplot for Ethereum Trading Volume by Quarter") +
   theme(text=element_text(size=16), 
         panel.grid.major = element_line(size=1.5),
         axis.ticks = element_line(size=1.4),
         axis.ticks.length = unit(0.20, 'cm')) +
   scale_color_manual(values = c("Gain" = "lightgreen", "Loss" = "red"))
```









```{r correlation}
scatterData <- data.frame(quarter = bitcoinData$quarter, bitcoin = bitcoinData$priceClose, ethereum = ethereumData$priceClose)

ggplot(scatterData, aes(x=ethereum, y=bitcoin)) +
   geom_point(aes(col=quarter)) + 
   geom_smooth(method=lm)

R <- cor(x=scatterData$bitcoin, y=scatterData$ethereum)
R2 <- R^2

correlation <- data.frame(R=R, R2=R2)
kable(correlation, digits=4)
```


```{r price by volume plot}
ggplot(filter(combinedData, cryptoCurrency=="Bitcoin")) +   
   geom_line(aes(x=date, y=priceClose, stat="identity")) +
   geom_bar(aes(x=date, y=volume/8, fill=dayPerformance), stat="identity") +
   scale_y_continuous(sec.axis = sec_axis(~ .*8, name="Volume")) +
   scale_fill_manual(values = c("Gain" = "lightgreen", "Loss" = "red"))
```

# Conclusion



